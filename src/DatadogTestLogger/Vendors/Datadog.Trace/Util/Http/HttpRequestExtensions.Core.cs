//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
// <copyright file="HttpRequestExtensions.Core.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

#if !NETFRAMEWORK
using System;
using System.Collections.Generic;
using System.Linq;
using Datadog.Trace.Vendors.Datadog.Trace.AppSec;
using Datadog.Trace.Vendors.Datadog.Trace.Configuration;
using Datadog.Trace.Vendors.Datadog.Trace.Logging;
using Datadog.Trace.Vendors.Datadog.Trace.Tagging;
using Datadog.Trace.Vendors.Datadog.Trace.Util.Http.QueryStringObfuscation;
using Microsoft.AspNetCore.Http;

namespace Datadog.Trace.Vendors.Datadog.Trace.Util.Http
{
    internal static partial class HttpRequestExtensions
    {
        private static readonly IDatadogLogger Log = DatadogLogging.GetLoggerFor(typeof(HttpRequestExtensions));

        internal static Dictionary<string, object> PrepareArgsForWaf(this HttpRequest request, Span relatedSpan)
        {
            var headersDic = new Dictionary<string, string[]>(request.Headers.Keys.Count);
            foreach (var k in request.Headers.Keys)
            {
                var currentKey = k ?? string.Empty;
                if (!currentKey.Equals("cookie", System.StringComparison.OrdinalIgnoreCase))
                {
                    currentKey = currentKey.ToLowerInvariant();
#if NETCOREAPP
                    if (!headersDic.TryAdd(currentKey, request.Headers[currentKey]))
                    {
#else
                    if (!headersDic.ContainsKey(currentKey))
                    {
                        headersDic.Add(currentKey, request.Headers[currentKey]);
                    }
                    else
                    {
#endif
                        Log.Warning("Header {key} couldn't be added as argument to the waf", currentKey);
                    }
                }
            }

            var cookiesDic = new Dictionary<string, List<string>>(request.Cookies.Keys.Count);
            for (var i = 0; i < request.Cookies.Count; i++)
            {
                var cookie = request.Cookies.ElementAt(i);
                var currentKey = cookie.Key ?? string.Empty;
                var keyExists = cookiesDic.TryGetValue(currentKey, out var value);
                if (!keyExists)
                {
                    cookiesDic.Add(currentKey, new List<string> { cookie.Value ?? string.Empty });
                }
                else
                {
                    value.Add(cookie.Value);
                }
            }

            var queryStringDic = new Dictionary<string, List<string>>(request.Query.Count);
            // a query string like ?test&[$slice} only fills the key part in dotnetcore and in IIS it only fills the value part, it's been decided to make it a key always
            foreach (var kvp in request.Query)
            {
                var value = kvp.Value;
                var currentKey = kvp.Key ?? string.Empty; // sometimes key can be null

                if (!queryStringDic.TryGetValue(currentKey, out var list))
                {
                    queryStringDic.Add(currentKey, new List<string> { value });
                }
                else
                {
                    list.Add(value);
                }
            }

            var dict = new Dictionary<string, object>
            {
                { AddressesConstants.RequestMethod, request.Method },
                { AddressesConstants.RequestUriRaw, request.GetUrl() },
                { AddressesConstants.RequestQuery, queryStringDic },
                { AddressesConstants.RequestHeaderNoCookies, headersDic },
                { AddressesConstants.RequestCookies, cookiesDic },
                { AddressesConstants.RequestClientIp, relatedSpan.GetTag(Trace.Tags.HttpClientIp) }
            };

            return dict;
        }

        internal static string GetUrl(this HttpRequest request, QueryStringManager queryStringManager = null)
        {
            var queryString = request.QueryString.Value;
            return HttpRequestUtils.GetUrl(
                request.Scheme,
                request.Host.Value,
                request.PathBase.ToUriComponent(),
                request.Path.ToUriComponent(),
                queryString,
                queryStringManager);
        }
    }
}
#endif
